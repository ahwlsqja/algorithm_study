## 목차
1. [그리디(Greedy) 알고리즘](#1-그리디greedy-알고리즘)
2. [구현(Implementation)](#2-구현implementation)

---

## 1. 그리디(Greedy) 알고리즘

### 개념
- **그리디 알고리즘(탐욕법)**: 현재 상황에서 지금 당장 좋은 것만 고르는 방법
- 문제에서 요구하는 최적의 해를 구할 수 있는지 **정당성 검토**가 매우 중요
- 일반적으로 최적의 해를 보장하지 못하지만, 코딩 테스트에서는 탐욕법으로 최적해를 구할 수 있는 문제가 자주 출제

### 핵심 포인트
-  **최소한의 아이디어**: 문제를 풀기 위한 최소한의 아이디어를 떠올릴 수 있는 능력 필요
-  **정당성 분석**: 현재 상황에서 가장 좋아 보이는 것을 선택하는 것이 최적의 해를 보장하는지 검토 필수

### 문제 목록

#### 1.1 거스름돈 문제 (Coin Change Problem)

**문제 설명**
- 500원, 100원, 50원, 10원짜리 동전이 무한히 존재
- N원을 거슬러 줄 때, 최소 동전 개수를 구하기
- N은 항상 10의 배수

**접근 방법**
- 가장 큰 화폐 단위부터 돈을 거슬러 주기
- 예: 1,260원 = 500원×2 + 100원×2 + 50원×1 + 10원×1

**정당성 분석**
- 큰 단위가 항상 작은 단위의 배수이므로 그리디 방식이 최적해 보장
- 만약 큰 단위가 작은 단위의 배수가 아니라면 최적해를 보장할 수 없음

**Python 코드**
```python
def coin_change(n):
    coins = [500, 100, 50, 10]
    count = 0
    
    for coin in coins:
        count += n // coin
        n %= coin
    
    return count

# 예시
n = 1260
print(coin_change(n))  # 6
```

**시간 복잡도**: O(K) - K는 화폐의 종류

---

#### 1.2 1이 될 때까지 (Until It Becomes 1)

**문제 설명**
- 주어진 N을 1로 만들기 위해 두 가지 연산 중 하나를 반복
  1. N에서 1을 빼기
  2. N을 K로 나누기 (N이 K로 나누어 떨어질 때만 가능)
- N과 K는 10만 이하의 자연수
- 최소 연산 횟수를 구하기

**접근 방법**
- N을 가능한 한 많이 K로 나누기
- K가 2 이상이므로, K로 나누는 것이 1을 빼는 것보다 빠르게 N을 줄임


**Python 코드(동빈나의 풀이)**
```python
def until_one(n, k):
    result = 0
    
    while n >= k:
        # N이 K로 나누어 떨어지지 않는다면 나누어 떨어지는 수까지 빼기
        target = (n // k) * k # 이렇게 하는 아이디어가 좀 발상적임...
        result += (n - target)
        n = target
        
        # K로 나누기
        n //= k
        result += 1
    
    # 마지막으로 남은 수에 대하여 1씩 빼기
    result += (n - 1)
    return result

# 예시
n, k = 25, 5
print(until_one(n, k))  # 2
```

---

#### 1.3 곱하기 혹은 더하기 (Multiply or Add)

**문제 설명**
- 숫자로만 이루어진 문자열 S가 주어짐
- 왼쪽부터 오른쪽으로 숫자를 확인하며 곱하기 또는 더하기 연산자를 넣어 최대값 만들기
- 모든 연산은 왼쪽에서부터 순차적으로 이루어짐 (사칙연산 우선순위 무시)

**접근 방법**
- 대부분의 경우 곱하기가 더 큰 값을 만듦
- 단, 두 수 중 하나라도 0 또는 1인 경우에는 더하기가 더 효율적 -> 이게 키 아이디어라고 생각함.

**Python 코드(동빈나의 풀이)**
```python
def max_value(s):
    result = int(s[0])
    
    for i in range(1, len(s)):
        num = int(s[i])
        # 두 수 중에서 하나라도 '0' 혹은 '1'인 경우, 더하기 수행
        if num <= 1 or result <= 1:
            result += num
        else:
            result *= num
    
    return result

# 예시
s = "02984"
print(max_value(s))  # 576
```

---

#### 1.4 모험가 길드 (Adventurer's Guild)

**문제 설명**
- N명의 모험가가 각각 공포도 X를 가짐
- 공포도가 X인 모험가는 반드시 X명 이상으로 구성된 그룹에 참여해야 함
- 만들 수 있는 그룹 수의 최댓값 구하기
- 일부 모험가는 그룹에 참여하지 않아도 됨

**접근 방법**
- 공포도를 오름차순으로 정렬
- 공포도가 낮은 모험가부터 그룹에 포함시키기
- 현재 그룹 인원이 현재 모험가의 공포도 이상이면 그룹 결성

**Python 코드(동빈나의 풀이)**
```python
def adventure_guild(n, fears):
    fears.sort()  # 공포도를 오름차순으로 정렬
    
    result = 0  # 총 그룹의 수
    count = 0   # 현재 그룹에 포함된 모험가의 수
    
    for fear in fears:
        count += 1  # 현재 그룹에 해당 모험가를 포함시키기
        if count >= fear:  # 현재 그룹에 포함된 모험가의 수가 현재의 공포도 이상이라면
            result += 1    # 그룹 결성
            count = 0      # 현재 그룹에 포함된 모험가의 수 초기화
    
    return result

# 예시
n = 5
fears = [2, 3, 1, 2, 2]
print(adventure_guild(n, fears))  # 2
```

---

## 2. 구현(Implementation)

### 개념
- **구현**: 머릿속의 알고리즘과 생각을 소스 코드로 바꾸는 과정
- 풀이를 떠올리는 것은 쉽지만 소스 코드로 옮기기 어려운 문제

### 구현 문제 유형
1. **코드의 길이가 긴 문제**: 알고리즘은 간단하지만 코드가 길어지는 문제
2. **문법적 특성을 활용하는 문제**: 특정 소수점 자리까지 출력, 문자열 처리 등
3. **라이브러리 활용**: 순열/조합 등 적절한 라이브러리 사용이 필요한 문제
4. **2차원 공간 처리**: 2차원 맵이나 행렬에서의 위치 이동, 시뮬레이션 문제

### 2차원 공간 다루기
- **좌표계**: 문제에서는 (1,1)부터 시작하는 경우가 많지만, 코드에서는 (0,0)부터 시작
- **방향 벡터**: 상하좌우 이동을 위한 dx, dy 배열 활용

### 문제 목록

#### 2.1 상하좌우 (Up, Down, Left, Right)

**문제 설명**
- N × N 크기의 정사각형 공간
- 여행가 A는 (1, 1)에서 시작
- 계획서(L, R, U, D)에 따라 이동
- 공간을 벗어나는 움직임은 무시
- 최종 위치 구하기

**접근 방법**
- 방향 벡터(dx, dy)를 사용하여 이동 구현
- 공간을 벗어나는지 확인 후 이동
- 여기에서 왜 대체 dx = [0, 0, -1, 1] 이고 dy = [-1, 1, 0, 0] 일까 해서 찾아봤는데 아래 처럼 되어서 각 증분을 그냥 편하게한거임.

**방향 벡터 이해하기**

| 방향 | move_types | dx | dy | 설명 |
|------|------------|----|----|------|
| L | 'L' | 0 | -1 | 왼쪽으로 이동 (열 감소) |
| R | 'R' | 0 | 1 | 오른쪽으로 이동 (열 증가) |
| U | 'U' | -1 | 0 | 위로 이동 (행 감소) |
| D | 'D' | 1 | 0 | 아래로 이동 (행 증가) |


**Python 코드(동빈나의 풀이)**
```python
def travel(n, plans):
    x, y = 1, 1
    
    # L, R, U, D에 따른 이동 방향
    dx = [0, 0, -1, 1]
    dy = [-1, 1, 0, 0]
    move_types = ['L', 'R', 'U', 'D']
    
    for plan in plans:
        # 이동 후 좌표 구하기
        for i in range(len(move_types)):
            if plan == move_types[i]:
                nx = x + dx[i]
                ny = y + dy[i]
        
        # 공간을 벗어나는 경우 무시
        if nx < 1 or ny < 1 or nx > n or ny > n:
            continue
        
        # 이동 수행
        x, y = nx, ny
    
    return x, y

# 예시
n = 5
plans = ['R', 'R', 'R', 'U', 'D', 'D']
print(travel(n, plans))  # (3, 4)
```

---

#### 2.2 시각 (Time)

**문제 설명**
- 정수 N이 입력되면 00시 00분 00초부터 N시 59분 59초까지의 모든 시각 중
- 3이 하나라도 포함되는 모든 경우의 수 구하기

**접근 방법**
- 완전 탐색(Brute Force)
- 하루는 86,400초로 모든 경우를 확인 가능
- 시, 분, 초를 문자열로 변환하여 '3' 포함 여부 확인

**Python 코드(동빈나의 풀이)**
```python
def count_time_with_3(n):
    count = 0
    
    for h in range(n + 1):
        for m in range(60):
            for s in range(60):
                # 매 시각 안에 '3'이 포함되어 있다면 카운트 증가
                if '3' in str(h) + str(m) + str(s):
                    count += 1
    
    return count

# 예시
n = 5
print(count_time_with_3(n))  # 11475
```

---

#### 2.3 왕실의 나이트 (Royal Knight)

**문제 설명**
- 8×8 좌표 평면의 체스판
- 나이트의 현재 위치가 주어졌을 때 이동할 수 있는 경우의 수 구하기
- 나이트는 L자 형태로 이동

**접근 방법**
- 나이트가 이동할 수 있는 8가지 방향을 정의
- 각 방향으로 이동 가능한지 확인

**Python 코드**
```python
def knight_moves(position):
    # 현재 나이트의 위치 입력받기
    row = int(position[1])
    column = int(ord(position[0])) - int(ord('a')) + 1
    
    # 나이트가 이동할 수 있는 8가지 방향 정의
    steps = [(-2, -1), (-1, -2), (1, -2), (2, -1), 
             (2, 1), (1, 2), (-1, 2), (-2, 1)]
    
    # 8가지 방향에 대하여 각 위치로 이동이 가능한지 확인
    result = 0
    for step in steps:
        # 이동하고자 하는 위치 확인
        next_row = row + step[0]
        next_column = column + step[1]
        
        # 해당 위치로 이동이 가능하다면 카운트 증가
        if 1 <= next_row <= 8 and 1 <= next_column <= 8:
            result += 1
    
    return result

# 예시
position = "a1"
print(knight_moves(position))  # 2
```

---

#### 2.4 문자열 재정렬 (String Rearrangement)

**문제 설명**
- 알파벳 대문자와 숫자(0~9)로만 구성된 문자열 입력
- 모든 알파벳을 오름차순으로 정렬하여 출력
- 그 뒤에 모든 숫자를 더한 값을 이어서 출력

**접근 방법**
- 문자열을 순회하며 알파벳과 숫자 분리
- 알파벳은 정렬, 숫자는 합산

**Python 코드**
```python
def rearrange_string(s):
    result = []
    value = 0
    
    # 각 문자를 하나씩 확인하며
    for x in s:
        # 알파벳인 경우 결과 리스트에 삽입
        if x.isalpha():
            result.append(x)
        # 숫자는 따로 더하기
        else:
            value += int(x)
    
    # 알파벳을 오름차순으로 정렬
    result.sort()
    
    # 숫자가 하나라도 존재한다면 가장 뒤에 삽입
    if value != 0:
        result.append(str(value))
    
    # 최종 결과 출력 (리스트를 문자열로 변환)
    return ''.join(result)

# 예시
s = "K1KA5CB7"
print(rearrange_string(s))  # ABCKK13
```

---

## 출처
- [이것이 취업을 위한 코딩 테스트다 with 파이썬](https://www.youtube.com/watch?v=2zjoKjt97vQ&list=PLRx0vPvlEmdAghTr5mXQxGpHjWqSz0dgC&index=2)

---












