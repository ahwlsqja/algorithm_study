# 그리디 알고리즘(탐욕법)
- 현재 상황에서 **지금 당장 좋은 것**만 고르는 방법
- 그리디 해법은 정당성 분석이 중요
	
    - 단순히 좋아 보이는 것을 반복해도 최적의 해를 구할 수 있는가?
    - 일반적인 상황에서 최적의 해를 보장할 수 없을 때가 많다.
    - 코딩 테스트에서는 탐욕법으로 얻은 해가 최적의 해가 되는 상황에서 이를 추론할 수 있어야 풀리도록 출제된다. 

## 예제 - <문제1> 1이 될때까지
![](https://velog.velcdn.com/images/owlemily/post/4c4fd367-4057-4a04-a234-8ac709016c74/image.png)
![](https://velog.velcdn.com/images/owlemily/post/662c95ed-fb80-46f3-b057-784ed41e9acc/image.png)
## 풀이
```python
N, K = map(int, (input().split()))
count = 0
while(True):
    if N == 1:
        break
    if N % K == 0:
        N = N//K
        count += 1
    else:
        N = N-1
        count += 1

print(count)
```
이 문제는 100,000 이하의 자연수이기 때문에 이렇게 구현해도 된다.
최악의 경우 시간복잡도가 O(N)이 나오게 된다.

N이 100억, 1000억이 넘어가는 엄청 큰 수가 된다면? 위의 코드는 불가능..
시간복잡도를 O(logN)으로 줄일 수 있는 코드는 아래와 같다. 
```python
n, k = map(int, input().split())

result = 0

while True:
	#N이 K로 나누어 떨어지는 수가 되도록 target이라는 변수에 세팅한다.
    target = (n//k) * k
    result += (n-target) #1을 빼야하는 횟수(연산횟수)를 결과에 더해준다.
    n = target
    
    if n < k: #n이 k보다 작으면 더이상 나눌 수 없으므로 반복문을 탈출해준다.
    	break 
    result += 1 #k로 나눈 횟수 더해주기
    n = n // k

# n<k일 때 while문이 break되었으므로 남은 수를 1로 만들어주기 위한 횟수를 더해준다.
result += (n-1)
print(result)
```
이 코드에서는
- 1을 빼는 연산횟수를 한번에 더해주었다.
- while문이 한번 반복될때 n//k 연산을 무조건 수행해서 연산횟수가 기하급수적으로 줄어든다. 
- 시간복잡도: **O($log_K N$) **

## 예제 - <문제2> 곱하기 혹은 더하기
---
![](https://velog.velcdn.com/images/owlemily/post/c944a01f-a87f-4664-9e8e-8453af14d7f2/image.png)

---
- 일반적인 프로그래밍 언어에서 정수데이터를 위해 기본 int형을 사용할 경우 약 21억까지 값이 형성될 수 있다. 파이썬에서는 수의 제한이 없기 때문에(필요한만큼 메모리를 확장하여 제한없이 매우 큰 수를 다룰 수 있음 arbitrary-precision integer) 이런 조건이 없어도 되지만 다른 프로그래밍 언어를 위해 이런 조건이 부여되었다. 
![](https://velog.velcdn.com/images/owlemily/post/0e8e1c25-2c8b-4bb4-af3e-80a6c50676ff/image.png)

## 풀이
- 대부분의 경우 +보다는 x가 더 큰 값을 만든다.
- 그러나 예외적으로 0과 1일때 주의하자. 0과 1일때는 더하는 것이 더 큰 수를 만든다.
- 예외를 생각하는 것이 포인트!
```python
s = input()

answer = int(s[0]) # 처음 시작은 0번째 자리로 세팅하기

for i in range(1, len(s)):
    num = int(s[i])
    if num <= 1 or answer <=1: # 1이하라고 하는 것도 아이디어인 것 같다.
        answer += num
    else:
        answer *= num
print(answer)
```
## 예제 - <문제3> 
![](https://velog.velcdn.com/images/owlemily/post/ce987163-2127-4099-9177-f8683be94072/image.png)
![](https://velog.velcdn.com/images/owlemily/post/f9223540-45a3-4122-8f32-a0385c93b304/image.png)
![](https://velog.velcdn.com/images/owlemily/post/5475d8be-1cb8-48ff-86f2-b4cef1df24f8/image.png)
- 현재 그룹에 포함된 모험가의 수가 현재 확인하고 있는 공포도보다 크거나 같으면 바로 그룹을 결성해버린다.
- 공포도가 낮은 순부터 그룹를 결성해서 최소한의 모험가의 수만 포함하게 되므로 최대한 그룹의 개수를 늘리는 전략이다.
```python
N = int(input())
ls = list(map(int, input().split()))

ls.sort()
#group = [0] * (N+1)
group = 0 #그룹 개수
count = 0 #인원 개수
for i in range(len(ls)):
    count += 1
    if i <= count:
        group += 1
        count = 0 #count = 0으로 하는 것을 생각못했음

print(group)
```
- `count = 0`으로 만들어서 현재 그룹의 인원수를 초기화 시켜주는 과정이 필요하다. 


# 구현: 시뮬레이션과 완전 탐색
![](https://velog.velcdn.com/images/owlemily/post/9f576756-7afb-478c-9bef-7b317991a5f0/image.png)
그림이 귀여워서 넣어보았다 ㅎ

구현이란, 머릿속에 있는 알고리즘을 소스코드로 바꾸는 과정이다. 
사실 모든 문제를 구현이라고 할 수 있지만, 특정 문제를 구현이라고 부르는 건 풀이를 떠오르는 건 쉽지만 소스코드로 옮기기 어려운 문제를 지칭한다. 

구현문제 유형의 예시를 살펴보자.
- 알고리즘은 간단한데 코드가 지나칠 만큼 길어지는 문제 
-> 이런 문제는 프로그래밍 언어마다 좀 다르다. 
- 실수 연산을 다루고, 특정 소수점 자리까지 출력해야 하는 문제
- 문자열을 특정한 기준에 따라서 끊어 처리해야 하는 문제
- 적절한 라이브러리를 찾아서 사용해야하는 문제

많은 라이브러리들이 존재한다는 것을 공부해놓자

## Implementation
일반적으로 알고리즘 문제에서의 2차원 공간은 행렬(Matrix)을 의미한다. 

코딩테스트에서도 이런 2차원공간의 "map에서 한 좌표에 존재하는 캐릭터가 반복적으로 어떤 위치로 이동한다."와 같은 문제들이 많이 등장한다.
![](https://velog.velcdn.com/images/owlemily/post/4a526a15-593b-448d-8514-bce32217236c/image.png)

- 시뮬레이션 및 완전 탐색 문제에서는 2차원 공간에서의 방향 벡터가 자주 활용된다. 
![](https://velog.velcdn.com/images/owlemily/post/32a58cac-5fa6-4162-85fe-fcb719798ecf/image.png)
x는 행, y는 열을 의미한다. 

## 예제 - <문제4>
![](https://velog.velcdn.com/images/owlemily/post/31505d3e-71ee-4b89-a4c2-07cc5442cb97/image.png)
![](https://velog.velcdn.com/images/owlemily/post/5082f67d-bab1-4ae4-b7e3-3c481cda8950/image.png)
![](https://velog.velcdn.com/images/owlemily/post/9ef1e958-b180-419c-a080-79fc93a85a89/image.png)

- 이 문제는 명령에 따라서 개체를 차례로 이동시킨다는 점에서 시뮬레이션 유형으로 분류된다.(알고리즘 교재나 문제 풀이 사이트에 따라서 다르게 일컬을 수 있어서 코테에서의 시뮬레이션 유형, 구현 유형, 완전 탐색 유형은 서로 유사한 점이 많다는 것만 기억하자)

```python
N = int(input())
plan = list(input().split())

#L, R, U, D
dx = [0, 0, -1, 1]
dy = [-1, 1, 0, 0]
x = 1
y = 1

for i in range(len(plan)):
    if plan[i] == 'L':
        nx = x + dx[0]
        ny = y + dy[0]
    elif plan[i] == 'R':
        nx = x + dx[1]
        ny = y + dy[1]
    elif plan[i] == 'U':
        nx = x + dx[2]
        ny = y + dy[2]
    else:
        nx = x + dx[3]
        ny = y + dy[3]
    
    if nx <= N and ny <= N and nx >= 1 and ny >= 1: #범위내에 있다면 현재 위치(x, y) 바꿔주기
        x = nx
        y = ny

print(x, y)

```
나는 위와 같이 풀었는데 L, R, U, D를 배열에 넣고 반복문을 이용할 수도 있다. 
```python
n = int(input())
x, y = 1, 1
plans = input().split()

#L, R, U, D에 따른 이동 방향
dx = [0, 0, -1, 1]
dy = [-1, 1, 0, 0]
move_types = ['L', 'R', 'U', 'D']

#이동계획 하나씩 확인
for plan in plans:
	for i in range(len(move_types)):
    	if plan == move_types[i]:
        	nx = x + dx[i]
            ny = y + dy[i]
    #공간을 벗어나면 무시
    if nx < 1 or ny < 1 or nx > n or ny > n:
    	continue
    #이동수행
    x, y = nx, ny
    
print(x, y)
```

## 예제 - <문제5>
![](https://velog.velcdn.com/images/owlemily/post/782b1909-8a93-462c-b9f5-e09ee6cc910c/image.png)
![](https://velog.velcdn.com/images/owlemily/post/0a5adf7c-506b-4938-b74e-31f363f8b23a/image.png)

- 이 문제는 **가능한 모든 시각의 경우**를 하나씩 모두 세서 푸는 문제이다. 
전형적인 완전 탐색 문제! (Brute Forcing 문제)
- 모든 경우의 수 : 24 * 60 * 60 = 86,400 
_-> 파이썬을 통해 문제를 풀때 1초에 20,000,000번 정도의 연산을 수행한다고 가정하고 문제를 풀면 된다. 위의 경우의 수는 그렇게 많은 수가 아니다. _

```python
# 완전 탐색 문제 
N = int(input())
time = ""
count = 0
for i in range(N+1):
    for j in range(60):
        for k in range(60):
            time = str(i) + str(j) + str(k)
            if '3' in time:
                count += 1
                time = ""

print(count)
```

## 예제 - <문제6>
![](https://velog.velcdn.com/images/owlemily/post/e9c51286-bb81-4276-80e6-7e8aa9a327a0/image.png)
![](https://velog.velcdn.com/images/owlemily/post/b5e5b1e0-a505-4f1d-8972-fed7c4afd199/image.png)
![](https://velog.velcdn.com/images/owlemily/post/a1c5de64-f413-4578-969f-39b2fabf5fd7/image.png)
나는 dx, dy 배열을 2개로 놓고 8가지 방향으로 위치를 이동하는 것을 구현했다. 
```python
s = input()
count = 0 #이동할 수 있는 경우의 수

dx = [1, -1, 1, -1, 2, 2, -2, -2]
dy = [2, 2, -2, -2, 1, -1, 1, -1]

y = (ord(s[0]) - ord('a')) + 1 # 1을 더해주는 것을 주의 (1, 2, 3, 4..., 8)
x = int(s[1])
for i in range(len(dx)):
    nx = x + dx[i]
    ny = y + dy[i]
    if ny > 8 or ny < 1 or nx < 1 or nx > 8: #아스키코드로 숫자로 바꿔주었으니 범위를 확인할 때 숫자로 확인해도 된다. 
        continue
    else:
        count += 1

print(count)
```
강의에서는 나이트가 이동하는 8가지의 방향을 하나의 2차원 배열로 표기하였다. 
```python
input_data = input()
row = int(input_data[1]
column = int(ord(input_data[0])) - int(ord('a')) + 1

#나이트가 이동하는 8가지 방향
steps = [(-2, -1), (-1, -2), (1, -2), (2, -1), (2, 1), (1, 2), (-1, 2), (-2, 1)]

#8가지 방향에 대하여 각 위치로 이동이 가능한지 확인
result = 0
for step in steps:
	#이동하고자 하는 위치 확인
    next_row = row + step[0]
    next_column = column + step[1]
    #해당 위치로 이동이 가능하면 카운트 증가
    if next_row >= 1 and next_row <= 8 and next_column >= 1 and next_column <= 8:
    	result += 1
        
print(result)
```

## 예제 - <문제7>
![](https://velog.velcdn.com/images/owlemily/post/be5a4f33-ef5d-4f90-977e-4ad02211ed57/image.png)
![](https://velog.velcdn.com/images/owlemily/post/8878b3fd-cec2-46ff-b24b-8dd2ddb34fbb/image.png)
- 요구사항대로 구현하면 되는 문제이다. 
- 문자열이 입력되면 문자를 하나씩 확인하고 숫자면 따로 합계를 계산하고, 알파벳이면 별도의 리스트에 저장한다. 
- 리스트에 저장된 알파벳을 정렬해서 출력하고, 합계는 뒤에 이어 붙여 출력한다.
```python
S = input()
num_sum = 0
s = []
for i in range(len(S)):
    if S[i].isdigit():
        num_sum += int(S[i])
    else:
        s.append(S[i])

s.sort()
a = ""
for i in s:
    a+=i
print(a, end="")
if num_sum != 0:
	print(num_sum)
```
- 이때 숫자가 하나도 존재하지 않을 수 있기 때문에(이럴 경우 0이 문자뒤에 붙어 출력된다.) 숫자의 합이 0인 예외의 경우를 처리해줘야한다.

나는 **숫자인지** 확인했는데
강의의 풀이에서는 **문자인지** 확인했다.


```python
data = input()
result = []
value = 0

for x in data:
	if x.isalpha():
    	result.append(x)
    else:
    	value += int(x)

#알파벳을 오름차순으로 정렬
result.sort()

#숫자가 하나라도 존재하면 가장 뒤에 삽입
if value != 0:
	result.append(str(value))

#최종 결과 출력(리스트를 문자열로 변환하여 출력)
print(''.join(result))
```
- 나는 리스트의 값을 공백없이 출력할 때 그냥 반복문을 통해 문자열로 합치는 방식으로 했는데
- 풀이에서는 `.join`을 이용하여 문자열로 변환하였다.

> **참고**
현재 참여하고 있는 코딩테스트 스터디 깃헙 링크입니다^^
https://github.com/ahwlsqja/algorithm_study
