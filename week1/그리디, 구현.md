# 구현 & 그리디 알고리즘 정리

## 구현 (Implementation)

> 아이디어를 실제 코드로 옮기는 능력

### 문제 유형
- 완전 탐색
- 시뮬레이션
- 문자열 처리
- 좌표 이동

### 대표 문제

---

### 문자열 재정렬

**문제 설명**  
알파벳 대문자 + 숫자로 이루어진 문자열이 주어졌을 때,  
모든 알파벳을 오름차순 정렬 후 숫자는 모두 더해 맨 뒤에 붙이기

**풀이 방법**
1. 문자열을 순회하면서 문자는 `result`, 숫자는 `value`에 저장
2. `result`를 정렬하고 숫자 합 `value`를 뒤에 붙여 출력

**예시 코드**
```python
data = input()
result = []
value = 0

for x in data:
    if x.isalpha():
        result.append(x)
    else:
        value += int(x)

result.sort()
if value != 0:
    result.append(str(value))

print(''.join(result))
```

---

### 왕실의 나이트

**문제 설명**  
체스판 8x8에서 나이트가 이동할 수 있는 경우의 수 구하기 (L자 이동)

**풀이 방법**
1. 이동 가능한 방향을 리스트로 정의
2. 현재 위치에서 각 방향으로 이동해 유효한 좌표만 카운트

**예시 코드**
```python
input_data = input()
row = int(input_data[1])
col = ord(input_data[0]) - ord('a') + 1

steps = [(-2, -1), (-1, -2), (1, -2), (2, -1),
         (2, 1), (1, 2), (-1, 2), (-2, 1)]

count = 0
for dx, dy in steps:
    nx = row + dx
    ny = col + dy
    if 1 <= nx <= 8 and 1 <= ny <= 8:
        count += 1

print(count)
```

---

## 그리디 (Greedy)

> 매 순간 가장 좋아 보이는 선택을 하는 방법

### 특징
- 정렬 후 선택
- 지역적으로 최선 = 전역적으로 최선

### 대표 문제

---

### 곱하기 혹은 더하기

**문제 설명**  
문자열 형태의 숫자에서 각 숫자를 순서대로 처리하며, `+` 또는 `*` 를 사용하여 가장 큰 수 만들기

**풀이 방법**
1. 현재 값과 계산 결과가 1 이하일 경우 `+`, 그 외엔 `*`

**예시 코드**
```python
data = input()
result = int(data[0])

for i in range(1, len(data)):
    num = int(data[i])
    if result <= 1 or num <= 1:
        result += num
    else:
        result *= num

print(result)
```

---

### 모험가 길드

**문제 설명**  
공포도가 주어진 모험가들을 조건에 맞게 그룹지어 최대 그룹 수 구하기

**풀이 방법**
1. 공포도 기준 정렬
2. 현재까지 사람 수가 공포도 이상이면 그룹 결성

**예시 코드**
```python
n = int(input())
data = list(map(int, input().split()))
data.sort()

result = 0
count = 0

for i in data:
    count += 1
    if count >= i:
        result += 1
        count = 0

print(result)
```