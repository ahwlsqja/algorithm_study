# 1주차: 그리디 & 구현

## 그리디 알고리즘(탐욕법)
현재 상황에서 지금 당장 좋은 것만 고르는 방법을 의미한다.
문제를 풀기 위한 최소한의 아이디어를 떠올리면 된다.
<br>

### <문제1> 거스름 돈
```java
public class Main {

    public static void main(String[] args) {
        
        int n = 1260;
        int count = 0;
        int[] coin = {500, 100, 50, 10};

        for(int i=0; i<4; i++){
            count += n / coin[i];
            n %= coin[i];
        }

        System.out.println(count);
    }
}
```
<br>

### <문제2> 1이 될 때까지
```java
import java.util.*;

public class Main {

    public static void main(String[] args) {

        Scanner sc= new Scanner(System.in);
        int n = sc.nextInt();
        int k = sc.nextInt();
        int result = 0;

        while(true){
            // n을 k로 나눌 수 있는 가장 가까운 수(target)로 만드는것.
            // target까지 빼면 된다 
            int target = (n / k) * k;
            result += (n - target);     // 뺀 만큼을 횟수에 추가 
            n = target;
            if (n < k) break;

            //나누는 횟수를 더하기 
            result += 1;
            n /= k;
        }
        //나눌 수 없으면 남은 수만큼 1씩 빼고 바로 더하는 식
        result += (n - 1);
    }
}
```
<br>

### <문제3> 곱하기 혹은 더하기
- 곱하기가 값을 더 크게 만든다
- 수가 0 또는 1이라면 곱하기보다는 더하기를 수행하기
- 두 수 중에 하나라도 1이하인 경우에는 더하고, 두 수가 모두 2이상인 경우에는 곱하기
- 입력 예시1) 02984
- 출력 예시1) 576
```java
import java.util.*;

public class Main {

    public static void main(String[] args) {

        Scanner sc = new Scanner(System.in);
        String text = sc.nextLint();
        sc.close();

        int result = text.charAt(0) - '0';    
        for(int i=1; i<text.length(); i++){
            int num = text.charAt(i) - '0'    //숫자로 변환
            
            if(num <= 1 || result <= 1){
                result += num;
            }
            else {
                result *= num;
            }
        }
        System.out.println(result);
    }
}
```
<br>

### <문제4> 모험가 길드
- 한 마을에 모험가 N명
- 공포도가 X인 모험가는 반드시 X명 이상으로 구성한 모험가 그룹에 참여해야됨
- 여행을 떠날 수 있는 그룹 수의 최대값을 구하시오. 
- 앞에서부터 공포도를 하나씩 확인하며 '현재 그룹에 포함된 모험가의 수'가 '현재 확인하고 있는 공포도'보다 크거나 같다면 이를 그룹으로 설정하기
- 입력 예시1) 5
2 3 1 2 2
- 출력 예시1) 2

```java
import java.util.*;

public class Main {

    public static void main(String[] args) {

        Scanner sc = new Scanner(System.in);
        int N = sc.nextInt();
        int[] arr = new int[N];
        int count = 0;  //모험가의 수
        int group = 0;  //그룹의 수

        for(int i=0; i<N; i++){
            arr[i] = sc.next();
        }
        Arrays.sort(arr);   //오름차순 정렬

        for(int i=0; i<N; i++){
            count++;    //일단 그룹 하나에 모험가 한명 추가
            if(count >= arr[i]){
                group++;
                count = 0;  //그룹이 결성됐으므로 모험가 수를 초기화하기!!! 다음 그룹의 모험가 수를 세야함. 
            }
        }
        System.out.println(group);
    }
}
```


<br>
<br>
<br>
<br>

----


## 구현
머릿속에 있는 알고리즘을 소스코드로 바꾸는 과정
- 풀이를 떠올리는 것은 쉽지만, 소스코드로 옮기기 어려운 문제를 말한다


### <문제1> 상하좌우
- 입력 예시1) 5
             R R R U D D
- 출력 예시1) 3 4

```java
import java.util.*;
import java.io.*;

public class Main {

    public static void main(String[] args) throws IOException {

        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        int n = Integer.parseInt(br.readLine());

        String[] go = br.readLine().split(" ");
        int x = 1, y = 1;    //시작 위치 

        //L, R, U, D 방향 설정
        int[] dx = {0, 0, -1, 1};
        int[] dy = {-1, 1, 0, 0};
        char[] moveTypes = {'L', 'R', 'U', 'D'};

        for(int i=0; i<go.length; i++){
            char plan = go[i].charAt(0);    //charAt에 i가 아니라 0이다!!!

            int nx = x, ny = y;
            for(int j=0; j<4; j++){
                if(plan == moveTypes[j]){   //이동 방향 확인
                    nx = x + dx[j];
                    ny = y + dy[j];
                }    
            }
            // 공간을 벗어나는 경우 무시 
            if (nx < 1 || ny < 1 || nx > n || ny > n) continue;
            // 이동 수행 
            x = nx;
            y = ny;
        }

        System.out.println(x + " " + y);
    }
}
```